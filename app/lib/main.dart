import 'dart:convert'; // Import this for jsonEncode and jsonDecode
import 'package:clarify/providers/user_history_notifier.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:clarify/screens/main_screen.dart';
import 'package:clarify/providers/theme_provider.dart';
import 'firebase_options.dart'; // Generated by Firebase CLI
import 'types/analysed_link_response.dart';
import 'types/user_history_response.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await dotenv.load(fileName: ".env"); // Load environment variables
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Clarify',
      theme: ThemeData(
        primarySwatch: Colors.deepPurple,
      ),
      home: const ClarifyApp(),
    );
  }
}

class ClarifyApp extends ConsumerStatefulWidget {
  const ClarifyApp({super.key});

  @override
  _ClarifyAppState createState() => _ClarifyAppState();
}

class _ClarifyAppState extends ConsumerState<ClarifyApp> {
  static const platform = MethodChannel('com.clarify.app/api');

  @override
  void initState() {
    super.initState();
    _registerReceiver();
  }

  Future<void> _registerReceiver() async {
    try {
      platform.setMethodCallHandler((call) async {
        if (call.method == "historyUpdated") {
          ref.read(userHistoryProvider.notifier).refreshHistory();
          debugPrint("historyUpdated called");
        } else if (call.method == "addNewHistory") {
          print("********************************");
          debugPrint("addNewHistory called with data: ${call.arguments}");
          try {
            // Convert the received map to a JSON string, then decode it back to ensure the correct types
            final jsonString = jsonEncode(call.arguments);
            final Map<String, dynamic> data = jsonDecode(jsonString);
            debugPrint("Parsed data: $data");

            if (data['analysedLink'] == null) {
              throw Exception("Missing analysedLink in data");
            }

            final newHistoryItem = UserHistoryItem.fromJson(data);
            ref
                .read(userHistoryProvider.notifier)
                .addNewHistory(newHistoryItem);
            debugPrint("Successfully added new history item: $newHistoryItem");
          } catch (e) {
            debugPrint("Error parsing new history item: $e");
          }
        }
      });
    } on PlatformException catch (e) {
      debugPrint("Failed to register receiver: '${e.message}'.");
    }
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Clarify',
      theme: ref.watch(themeProvider),
      home: const MainScreen(),
    );
  }
}
